    // 
        pcode indicats ...
        网上资源其实也不少，但是总觉得不踏实，不系统
        题目肯定是无穷多的， tasks不可估计。但是知识点是有限的。
            不要被无限多的题目迷惑了双眼，掌握核心知识以后你也可以出题！
            所以有些题目没有看到也并不遗憾
            但是还是尽力多做题！整理他们的精华之处！   
        type of tasks: 
            DS free tasks
            lan-feature based
        算法是别人或者自己的，那怎么叫熟悉的语言？
            所有小task都可以毫不费力没有参考或者只参考笔记完成
            -这需要训练
                1.理解并设计tiny tasks 
                2.反复实现
        熟悉c++语言
            基本的概念了如指掌
            所有task信手拈来
        tasks 
            在fw中input怎么办？ -- hardcoded, in a header file!
            输出？ 横线作为标志 
        编程和语言很像，都是模仿。深层次的模仿叫创造，浅层次的模仿叫抄袭
        *如何积累？学cpp面向对象，数据结构，算法有什么不同？ 
            学cpp面向对象--没有错误就ok--self containing tasks --积累tasks(完整的)
            数据结构--没有错误就ok--积累tasks(完整的)
            算法--结果正确，高效--
                base case
                    积累tasks(完整的) + static test cases（不完整）
                integrated 
                    积累snippets！（不完整）
                (mixed!complicated!)
            项目功能--积累snippets！（不完整）
            ---
                (如何集成？-- methods based 
                    test1(){}
                    test2(){}
                    ...
                    int main(){
                        test1();
                    }
                越低的lev代码段越小，不必要snippet备份！ 
        *task based training
            the right ones, and improve
            bkp
            rewrite and ref. to bkp 
        code reuse? --> ref. to pieces!
        code judgement? 
            + 
            initial ideas: 
                test cases, unit test(expected input output, use assert func.) -- have seen someone uses 
                    consider about corner cases! software test! 
                    use standard methods to gen. test cases!! 
                benchmark
                    a larger version of test cases!
                    for computer vision, machine learning 
                vis it!, plot it out, we can easily judge it! 
                    for graphics 
        A simple and complete C++ program demonstration should be summ. 
        modeling skills also needed! 
            modeling + coding
        那些acmer高手，看似思路很快，其实就是知道的套路比你多
        boost your cpu 
        不要通过ACM这种形式来学习，性价比太低。
    ---c++ lan 
        seed--with exp
            Suggested Study Order
            by default, 5.0 refers to double in c++? y float? n 
                how to varify this with a code? easy. 
            N大数据类型？ 
                char, short, int, long, float, double, long double, bool 
            https://www.geeksforgeeks.org/nested-classes-in-c/
            friend, namespace, make_shared, make_pair, map...
            about the class in c++ 
                by default the access modifier for the members will be Private.
                Protected--can be accessed by any subclass(derived class) of that class.
                t- show the id in parent, and set it. with Protected modif. 
                    inherit, protected keyword 
                    -task_virtual func
            Inheritance 
                qq types of Inheritance? x5 
                qq does c++ support multiple Inheritance? y 
                Hybrid (Virtual) Inheritance
            Polymorphism 
                pp- access the child method in parent? 
                Real life example of polymorphism, a person at the same time can have different characteristic.
                Compile time Polymorphism  x2 
                    function overloading or operator overloading
                    multiple functions with same name but different parameters
                    change in number of arguments or/and change in type of arguments.
                Runtime Polymorphism
                    Function overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden
                    virtual function, binded at runtime (Runtime polymorphism) 
                    qq to show that we want to overwrite a func. in base class, we have to declear that the func. is virtual? y!
                    虚函数的作用是允许在派生类中重新定义与基类同名的函数
                    t- a base class and a drived class, access two methods, one is virtual and the other not.  
                        -task_virtual func
            Encapsulation 
                wrapping up of data and information under a single unit.
                Encapsulation is defined as binding together the data and the functions that manipulates them
                in a company there are different sections like the accounts section, finance section, sales section etc.
                Now there may arise a situation when for some reason an official from finance section needs 
                    all the data about sales in a particular month.
                Encapsulation also lead to data abstraction or hiding
                Class and access modifiers: getter and setters 
            Structure vs class in C++
                A Structure is not secure and cannot hide its implementation details from the end user while a class 
                    is secure and can hide its programming and designing details.
                Members of a class are private by default and members of a struct are public by default.
                security issues 
            qq Can a C++ class have an object of self type?
                static is fine 
            qq  static member functions do not have this pointer.? y not related to instance 
                A static member function can not be declared const
                The object called by these functions cannot be modified. 
            Local Classes in C++
                A local class type name can only be used in the enclosing function. invalid in main()
                all func. in this method 
            constructors 
                Default constructor is the constructor which doesn’t take any argument. It has no parameters.
                and does not have return val. at the same time 
                Constructor has same name as the class itself
                Constructors don’t have return type
                A constructor is automatically called when an object is created.
                default constructor expects no parameters and has an empty body
                qq three typies? 
                Point p2 = p1; // Copy constructor is called her
                qq what is a copy constructor? 
            initializer list 
                comma-separated list followed by a colon. 
                Test(int &t):t(t) {}
                t- write a point class and initialize it with initializer List 
                    -task_initialier
            deconstructor 
                A destructor function is called automatically when the object goes out of scope:
                    (1) the function ends
                    (2) the program ends
                    (3) a block containing local variables ends
                    (4) a delete operator is called 
                qq Can there be more than one destructor in a class? n 
                The default destructor works fine unless we have dynamically allocated memory or pointer in class.
                When a class contains a pointer to memory allocated in class, we should write a destructor to release 
                    memory before the class instance is destroyed. This must be done to avoid memory leak.
                t- constru. a string class and write a deconstructor for it! 
                    -task_deconstructor
            Copy elision (or Copy omission) 
                a compiler optimization technique avoid too many copy operations 
            The ‘fill’ function in STL 
                assigns the value ‘val’ to all the elements in the range [begin, end)
            c++ stl 
                c++ vector loop! 
                    Vectors are same as dynamic arrays with the ability to resize itself automaticall
                    Vector elements are placed in contiguous storage so that they can be 
                        accessed and traversed using iterators
                    lots of functions! 
                        https://www.geeksforgeeks.org/vector-in-cpp-stl/
                        Iterators 
                            begin(),end()... 
                        Capacity
                            reserve() – Requests that the vector capacity be at least enough to contain n elements.
                        Element access:
                            at() 
                            front() ... back()... 
                        *Modifiers! train them all! maybe in one file
                            push_back() 
                            pop_back()
                            insert() 
                            erase() 
                            emplace() 
                            emplace_back()
                            swap()
                            ...
                        qq diff. of  emplace_back and push_back? 
                            Well in C++17 will return a reference to element that was just created in the vector where as push_back does not return anythin
                            emplace_back will be more effi. when the case of passing an object such as a string 
                        t- train them all! maybe in one file
                            push_back() 
                            pop_back()
                            insert() 
                            erase() 
                            emplace() 
                            emplace_back()
                            swap()
                                -task_func of vector
                list stru. 
                    Lists are sequence containers that allow non-contiguous memory allocation
                    As compared to vector, list has slow traversal, but once a position has been found, insertion and deletion are quick!
                    qq diff. bet. vector and list? 
                    when we say a List, we talk about doubly linked list.
                    t- constru. a list which contains 2^n show and sort it! vis. it the sorting process!
                        push_back, push_front 
                        write a func. names show_list() 
                        we can call sort on a given list, vec? pp- 
                            -task_func of list
                    list_name.emplace(position, element)
                        It returns a random access iterator which points to the newly inserted element.
                    we may use auto in this case! 
                        auto it = lis.emplace(lis.begin(), 2); 
                    
            auto 
                can be used esp. the case of a returned value! 
                t- declaration a list of pair: int and a char, print them out, loop with keyword auto!     
                    -
            friend
                A friend class can access private and protected members of other class 
                a LinkedList class may be allowed to access private members of Node
                use case? LinkedList, Node 
                Friends should be used only for limited purpose.
                    it lessens the value of encapsulation of separate classes in object-oriented programming.
                Friendship is not mutual.not inherited
                friend class B; , means that we can access B in a, "B is my friend, my private vars. 
                    are allowed to be access. by B"
                "allow"
                t- demo. this friend with classes A and B C, B can access the private vars. 
                    of A and C, print them out. 
                    in two ways x2 
                        -task_keyword friend
                *the order of class blocks does matter? y how? 
                    - write *largest classes first(pp- ?) may work
                        smaller ones has private vars.  
                    - we have to follow the order of *header files and their imp. 
                        // cpp file below: (logically)
            Nested Classes
                nested class can access private members of Enclosing class, and not true the conter case 
            
                
                

            ...
        online--https://www.geeksforgeeks.org/c-plus-plus/
            basic 
                Functions provide abstraction. For example, 
                    we can use library functions without worrying about their internal working.
                Conclusion is scope resolution operator is for accessing static or class members 
                    and this pointer is for accessing object members when there is a local variable with same name.
            IO 
                Tokenizing a string in C++
            STL lib. - old
                是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数
                    可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈
                C++ 语言的核心优势之一就是便于软件的重用
                标准模板库 (Standard Template Library)就是一些常用
                    数据结构和算法的模板的集合。主要由 Alex Stepanov开发，
                    于1998年被添加进C++标准
                相对的，每个人都该实现一下自己的算法库
                    首先，可以提供新的研究成果，近似算法xxx
                    其次，方便理解，别人写的你总归是不理解的！
                有了STL，不必再从头写大多的标准数据结构和算法，并且可获得非常高的性能。
                核心：容器，迭代器，算法
                容器：可容纳各种数据类型的数据结构。
                    1) 顺序容器
                        vector：后部插入/删除，直接访问
                        deque：前/后部插入/删除，直接访问
                        list：双向链表，任意位置插入/删除
                    2)关联容器
                        set：快速查找，无重复元素
                        multiset ：快速查找，可有重复元素
                        map：一对一映射，无重复元素，基于关键字查找
                        multimap ：一对一映射，可有重复元素，基于关键字查找前2者合称为第一类容器
                    3)容器适配器
                        stack： LIFO
                        queue： FIFO
                        priority_queue：优先级高的元素先出容器概述
                
                    头文件
                        1) vector 头文件 <vector>
                            实际上就是个动态数组。随机存取任何元素都能在常数时间完成。
                                在尾端增删元素具有较佳的性能。
                        2) deque 头文件 <deque>
                            也是个动态数组，随机存取任何元素都能在常数时间完成(但性能次于vector)。
                                在两端增删元素具有较佳的性能。
                        3) list 头文件 <list>
                            双向链表，在任何位置增删元素都能在常数时间完成。    
                                不支持随机存取，查询的时候要从头开始。
            *STL 
                https://zh.m.wikibooks.org/wiki/C%2B%2B
                set
                    each element has to be unique
                    The value of the element cannot be modified once it is added to the set
                    set <int, greater <int> > :: iterator itr; 
                    t- basic usage of a set? 
                        https://www.geeksforgeeks.org/set-in-cpp-stl/
                        -task_basic_set
                vector, list
                    ...
                stack, queue, Priority Queue
                    push(g) and pop(), pop() function deletes the first element of the queue.
                    t- push some numbers into queue and write a showq func. that shows the 
                        elements of the queue 
                        https://www.geeksforgeeks.org/queue-cpp-stl/
                        -task_basic_queue
                    t- use a stack to inverse a list, vector, array? 
                        https://www.geeksforgeeks.org/stack-in-cpp-stl/
                        -task_basic_stack
                    Priority queue 
                        first element of the queue is the greatest of all elements in the queue and elements 
                            are in non increasing order
                    t- try max heap and min heap with help of Priority queue  x2 
                        https://www.geeksforgeeks.org/priority-queue-in-cpp-stl/
                        push and show the state of them!!
                        hard to rem min heap -- we can multiply values with -1 and use max heap 
                            to get the effect of min heap! * use this method! 
                            -task_maxminheap
                    --- variations
                        Forward list 
                            implements singly linked list. Introduced from C++11,
                                simpler version of list? pp- 
                            It differs from list by the fact that forward list keeps track of location of only next 
                                element while list keeps track to both next and previous elements.
                            thus increasing the storage space required to store each element.
                            The drawback of forward list is that it cannot be iterated backwards 
                                and its individual elements cannot be accessed directly.
                            Forward List is preferred over list when only forward traversal is required
                            *chaining in hashing, adjacency list representation of graph, etc.
                            std::list 是双向链表，每个成员保持指向下一项与前一项的两个指针，因此可以双向遍历，但消耗内存空间更多，插入或删除成员时的速
                            forward_list在容器内任意位置的成员的插入、提取（extracting）、移动、删除操作的速度更快，因此被广泛用于排序算法。
                        Double ended queues are sequence containers with the feature 
                            of expansion and contraction on both the ends.
                map 
                    Map in STL is used to hash key and value.
                    We can also use map for pairs.
                    t- use hashing tech to mark the posi. in a (large) Matrix. show where is not marked! 
                        given a matrix and positions visited, print which positions are not visited.
                        https://www.geeksforgeeks.org/map-pairs-stl/
                        -task_hashing task to mark
                range based loop 
                    Range-based for loop in C++ is added since C++ 11. It executes a for loop over a range. 
                    Used as a more readable equivalent to the traditional for loop operating
                    in a container* -- that means all containers in stl can be iterated in this way
                    t- Printing string characters, use range based loop ! 
                        https://www.geeksforgeeks.org/range-based-loop-c/
                        -task_printwithrangebasedloop
                Multisets 
                    are a type of associative containers similar to set, 
                    with an exception that multiple elements can have same values.
                make_heap()
                    for vectors, make vectors into heaps 
                    using push_heap() to reorder elements 
                    https://www.geeksforgeeks.org/heap-using-stl-c/
                    v1.front() to access the maximum val. in a heap 
                    t- make a vector to heap and show the max. one. then push a val., reorder it! 
                        -task_make_heap
                K-ary heaps 
                    generalization of binary heap(K=2) in which each node have K children instead of 2
                    Max k-ary heap and Min 
                    faster decrease key operation as compared to binary heap
                    https://www.geeksforgeeks.org/k-ary-heap/
        book--c++ primer plus 
            // --x4days 
            // it was not so hard part, and seems not so interesting -- 耐住性子
            // what can i learn from such a reading?
                expressions of besic concepts 
                accurate know. about the c++ -- it is a basic task! 
                can occa. use better representation to model a problem when researching 
                precise! 
                do not be too detailed -- tasks should be meaningful 
                    eg. ignore: 
                        File IO: just basic is enough 
                        history of c++ 
                        ...
                list questions that can review c++ anytime you want by reviewing them 
                    and also, the tasks! refine them or re-implement them from time to time! 
                知识点琐碎，描述冗长。主要还是自己一知半解。
                一知半解的东西最难学：需要足够的耐性，时间。80%是已知的就会觉得很无聊
                好在主要看英文版的，很多表达我是没有接触过的！实在不行相当于在学英文！ 
            // 
                total pages = 1438    
                page gap = 15 
                cur page = 112, 
            ch02 38 pages 
                op42 
                Placing comments in a C++ program
                Similarly, when you learn a computer language, you should begin by learning
                    the basic structure for a program.
                it is similar to construct a simple home 
                an overview of the essential structure of a C++ program and previews some topics
                cout is a  facility to produce character output
                C++ is case sensitive
                    it discriminates between uppercase characters and lower case 
                compiler rejects your offering and accuses you of using unknown identifiers.
                include s are a PREPROCESSOR directive
                function header, func. body ! 
                Program Adjustments
                you can make the window stay open until you strike a key
                check the registration link on the back cover for more information
                back cover 
                You won’t regret it!
                uses C++’s input facilities, instead of c's input facilities
                organize a program into major tasks and then design separate 
                    functions to handle those
                A function body, delimited by { and }
                A return statement to terminate the main() function
                Stripped of the trimmings, we can see the fundamential struc. 
                function header,and the portion enclosed in braces ({ and })
                    - the portion enclosed in braces is called function body 
                However, the ISO Standard uses the term “braces.”
                In C++ each complete instruction is called a statement
                You must terminate each statement with a semicolon
                A statement represents an action to be taken
                The practical upshot is that in  C++ you should never omit 
                    the semicolon.
                who  can’t put their curiosity on hold
                a C++ function is activated, or called, by another function
                The part preceding the function name is called the function return type;
                The part within the parentheses following the function name
                    is  argument list or parameter list
                you normally don’t call main() from other parts of your program
                In effect, the function header describes the interface 
                    between main() and the operating system
                In this case, the empty parentheses mean that the main() function takes no information
                qq- what is the  original C style? 
                Using the keyword void in the parentheses is an explicit way of 
                    saying that the function takes no argument
                qq- we should not use vois main() style? 
                    should avoid this form and use the C++ Standard form;
                    not part of c++ standard 
                the implicit return is provided only for main() and not for     
                    any other function.
                op47 
                There’s an extremely compelling reason to name a main func. with 
                    main and not the others 
                Remember, case and spelling count
                that function must bear the responsibility of being main()
                execution always begins at the beginning of the main() function
                qq- what happends if you do not have a main func.? 
                    the compiler points out that you haven’t defined
                you can write a dynamic link library (DLL) module
                Because a DLL module is not a standalone program
                it does nt need a main() func. 
                some non-standard such as tmain() may exists, 
                    in that case there is a hidden main() that calls _tmain(). 
                    But your ordinary standalone program does need a main();
                double slash (//) introduces a C++ comment
                comments are usua. used to explain some aspect of the code
                qq- As far as the compiler is concerned, what does it looks like? 
                qq- what kinds of comments are there? x4 
                    c++ style, c style...
                    and /// for document generation 
                qq- we have to stick to c++ style? 
                    Because it doesn’t involve remembering to correctly pair
                    an end symbol with a begin symbol, it’s less 
                    likely to cause problems    
                filename extention depends on your C++ system
                The more complex the program, the more valuable comments are.
                The GNU compiler is available for many platforms
                Linux systems most commonly use g++, the GNU C++ compiler from the 
                    Free Software Foundation
                C comments, which are enclosed between /* and */ symbols
                (If your compiler doesn’t like these lines, it’s not C++98 compatible
                It automatically operates when you compile the program
                This directive causes the preprocessor to add the contents of the iostream file to 
                    your prog. 
                we need these def. in order to use the cout facility to
                    display a message
                op49 
                the original source file is not changed, but goes on to the next stage of compilation.
                Programs that use cin and cout for input and output must include the iostream file.
                C++ compilers come with many header files, each supporting a particular family of facilities
                initially, the header file supporting input and output was named iostream.h
                Now the h extension is reserved for the old C header files
                qq- why we not use iostream.h> as include filename? what is the diff. ? 
                C++ header files have no extension
                also C header files that have been converted to C++ header files
                    dropping the h extension (making it a C++-style name) and 
                    prefixing the filename with a c (indicating that it comes from C)
                dropping the h is more than a  cosmetic change, for the h-free header files also incorporate namespaces
                qq- how to explain the <cmath> header? where does it come? 
                naming conventions for header files.
                op50 
                This is called a using directive
                pre-existing code from several vendors
                help organize programs
                Piscine::wanda() could denote Piscine Corporation’s version of wanda()
                your program could now use the namespaces to discriminate between various versions:
                classes, functions,and variables that are a standard component are named in a namespace 
                    called std
                they can do so without a lot of hassle
                it is prefered to make just particular names available -- detail depends on the existing code 
                    in cgv 
                using namespace std; // lazy approach, all names available
                The part enclosed within the double quotation is a string var. 
                any series of characters enclosed in double quotation marks is called a character string
                the symbols point the way the information flows
                You don’t have to know the innards of an object in order to use it.
                qq- what is the conceptual view of printing a string out? 
                insertion operator (<<) that inserts the information on its right into the stream
                rather than say that your program displays a message, you can say that it inserts a string
                    into the output stream.
                in bkg, this happends by  Operator Overloading
                the same as bitwise left-shift operator (<<) in c lan 
                same operator symbol can have different meanings
                C itself has some operator overloading. For example, the & symbol represents both 
                    the address operator and the bitwise AND operator.
                The * symbol represents both multiplication and dereferencing a pointer
                redefine operator meanings for the user-defined types called classes.
                Inserting endl into the output stream causes the screen cursor to move to the 
                    beginning of the next line
                to try out these output examples, you have to place them in a complete program
                qq- we can also use \n to move to the next line? y 
                more ancient
                it is considered to be a single character called the newline character
                most people find the keystrokes for endl to be more comfortable
                qq- what is the diff. with "\n" and endl? 
                    endl guarantees the output will be flushed (in, this case, immediately displayed onscreen
                in c++, we can treat the carriage return in the same way as a space
                This is visually ugly but valid code
                they are collectively are termed white space
                qq- why this is invalid? 
                    intmain(); // INVALID, white space omitted
                An opening brace and a closing brace for a function, each of which is on its own line
                we should keeping the code clean and readable
                A C++ program is a collection of functions,and each function is a collection of statements
                op56 
                This practice is the usual C convention, but it’s somewhat less common in C++.
                The next few pages examine this program
                Computers are precise, orderly machines
                int is ,a number with no fractional part
                the size range depends on the implementation.
                we have to  check for omitted declarations
                The problem is that if you misspell the name of a variable
                This kind of error can be hard to trace
                in c++, compiler catches the error and stomps the potential bug.
                a declaration need not be a definition, but in this example it is
                the usual C++ style is to declare a variable just before it is first used.
                    That way, you don’t have to rummage back through a program to see what the type is
                *The C++ style for declaring variables is to declare a variable as close to its first use as possible.
                we can can use the assignment operator serially
                The assignment works from right to left. 
                    we read them as:  88 is assigned to steinway;
                c++ allows you Without going into the intricacies of printf()
                *In essence, the C++ insertion operator (<<) adjusts its behavior to fit the type of data
                to cling to your hard-won mastery of printf()
                That is, you can redefine the << operator so that cout can recognize and display new data types you develop
                And if you relish the fine control printf() provides
                op60 

                    
                ...
            ch03 50 pages
            ch04 80 pages 
            ch05 58 pages
            ch06 52 pages
            ch07 74 pages
            ch08 .. pages
            ch09 .. pages
            ch10 .. pages
            ch11 .. pages
            ch12 .. pages
            ch13 .. pages
            ch14 .. pages
            ch15 .. pages
            ch16 .. pages
            ch17 .. pages
            ch18 .. pages
            ch19 STL  .. pages
            ... 
        book--TeachYourself c++ in one hour a day
        book--old ones 
            +
                参考
                    http://www.runoob.com/cplusplus/cpp-comments.html
                概述	
                    编译语言与解释语言
                    最经典的编译语言是c，最经典的解释语言是Ruby
                    解释语言效率未必就低于编译语言，可以通过加强解释器来实现解释语言执行的优化
                    相比matlab，具有开源优势
                    相比java与c这种强类型语言，具有更好
                    强类型语言与弱类型语言
                        弱类型的语言的东西没有明显的类型,他能随着环境的不同,自动变换类型，比如vbs、javascript语言。变量声明比较简单，仅仅是var就可以解决。
                        强类型比如java、c
                    强类型语言实现数学操作比较费劲
                    编译器
                        mingw是gcc 的windows的移植版  
                        mingw支持win32API 单一编译器可以支持多个API 
                        主函数加载  变量声明 以及函数调用是受API说明 以及编译器支持的   
                        mingw  gcc编译器支持win32API    
                        c51   单片机编译器支持  c51API
                        gcc的各种版本：mingw
            //
                快速复习，’说破而不戳破‘
                把概念高度概括，起码自己再看的时候知道怎么回事，直接就可以写代码
                题目--笔记--code
                    不到万不得已不要看code，争取自己可以做出来 
                    笔记相当于一种有效快速的提示（网上的东西杂乱）
                    
            =======================语言基础=====================
                基本环境：引入iostream，其中定义了一些标准对象，使用std命名空间 打印hello &
                数据类型表达式
                    七种基本的 C++ 数据类型(小写)
                        int 
                        float double
                        char
                        bool
                    用大括号括起来是语句块
                    C++ 是区分大小写的编程语言，Manpower 和 manpower 是两个不同的标识符。
                    保留字不能作为常量名、变量名或其他标识符名称
                    三字符组就是用于表示另一个字符的三个字符序列，用来表示特殊字符
                    注释快捷键（VS2013）
                        注释Ctrl+K+C
                        取消Ctrl+K+U
                    块注释符（/*...*/）是不可以嵌套使用的。
                    使用 typedef 为一个已有的类型取一个新的名字 &
                        typedef int feet;feet distance;
                    枚举类型(enumeration)是C++中的一种派生数据类型
                        enum color { red, green, blue } c;
                        枚举名color，red标识符，c枚举常量
                        默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2
                        也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。
                        enum color { red, green=5, blue };
                        在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。
                    float 23位小数。double，52位小数
                    ***不带初始化的定义：
                        带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。
                    指向内存位置的表达式被称为左值表达式（lvalue）。
                    右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
                    变量是左值，因此可以出现在赋值号的左边
                    ***义全局变量时，系统会自动初始化！，为0值：
                    定义一个无符号长整数 &
                    定义一个浮点数常量，计算长度 &
                        314159E-5L 
                    空格可以分割字符串 &
                    使用 #define 预处理器定义常量 &（最好是大写字母）
                    有符号整数和无符号整数使用范围是不同的，输入一个正数，有符号整数可能解释为负数 50000 int &
                    自己的类定义
                        class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表
                        定义一个Box类，写get set方法，使用标准的定义过程，加上构造函数 &
                        构造函数
                            构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void ！
                            初始化列表来初始化字段
                            类成员函数或者构造函数定义的时候可以无歧义的直接使用成员变量名
                            应该是public 的
                            在main中使用时（两种都可以） &
                                不用new关键字：自动在栈中为每个变量开辟内存空间
                                使用new：在堆中创建，默认调用构造方法（动态内存）
                        成员属性
                            默认情况下，类的所有成员都是私有的
                            保护成员在派生类（即子类）中是可访问的
                            有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。
                        公共数据成员可以使用直接成员访问运算符 (.) 来访问
                        类定义内部仅仅进行成员函数声明，方便管理，声明就是一个函数头，没有函数体
                        类方法最好使用范围解析运算符 :: 来定义，在类定义外部
                        有元 *
                            有元函数可以不通过类名直接调用，但是没有this指针
                        内联函数 
                            比较大小的内联函数 &
                            如果已定义的函数多于10行，编译器会忽略 inline 限定符。
                            加快调用速度
                            实质是空间换时间
                                程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，
                                而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。
                        this指针
                            每一个对象都能通过 this 指针来访问自己的地址 *
                            因为友元不是类的成员。只有成员函数才有 this 指针。
                        指向类的指针
                            一个指向 C++ 类的指针与指向结构的指针类似
                            动态计算Box1 2的体积 &
                        类的静态成员
                            这意味着无论创建多少个类的对象，静态成员都只有一个副本。
                            实现一个类实例的计数器 &（每次构造的时候加1）
                    数组 
                        个数是固定的，为了效率
                        数组名可以直接用于指针运算
                        生成 10 个随机数，并使用数组来返回它们 &
                        数组地址传给函数，生成数组序列 &
                        字符串
                            C++ 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾
                            各种字符串操作: &
                                strcpy
                                strcat
                                strlen
                                strcmp
                                strchr
                            String类型|：
                                C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。
                    指针类型
                        动态内存分配，没有指针是无法执行的
                        连字号（&）运算符访问的地址，取地址操作
                        *是取值操作
                        注意区分指针的声明和使用
                        指针的实际数据类型是 是一个代表内存地址的长的十六进制数
                        指针可以用来指向一个真实的变量地址，用来取变量的数值，传值等操作
                        数组指针：指向数组开头的常量，不能作为左值
                            本身不可以变，但是取值之后的数值是可以变得
                        构造一个数组，把 var[2] 赋值为 500 &
                    引用类型
                        引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字
                        引用必须在创建时被初始化。指针可以在任何时间被初始化。
                        把引用当成是变量附属在内存位置中的第二个标签
                        引用就是取别名，直接操作就可以
                        主要应用
                            函数参数
                                交换两个int类型的数据 &
                            把引用作为返回值
                                不能返回局部变量的引用
                                可以出现在赋值语句左边，
                                写一个数组，改变数组中i位的数值 &
                    结构类型
                        结构是 C++ 中另一种用户自定义的可用的数据类型，同c语言中
                时间运算
                    C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数
                    引入ctime，而后可以调用time函数 输出秒数&
                    输出格式化的日期时间 &
                        strftime()函数

                数学运算
                    引用数学头文件 <cmath>
                    sin cos等静态函数操作 &
                函数
                    在函数声明时，最好提供一个函数名在main之前，而函数的实际定义则可以在任何地方进行
                    返回两个数字中较大的数 &
                    通过引用调用处理一个数组 &
                    Lambda 函数与表达式
                        增加可读性？一般不用
                    实现汉诺塔 &
                控制语句
                    循环分支for while if
                    输出上下三角 &
                    九九乘法表 &
                输入输出
                    cout<<"string"<<endl，endl是换行符
                    cin<<变量名；
                    流提取运算符 >> 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：

                    scanf("%d",&x);传地址
                    printf("%d",x);传数值
                刷ACM题目 &&
                命名空间
                    定义命名空间 &
                    using 指令
                    嵌套的命名空间
            =======================深入API（实现各种算法应用）===================
                文件操作（最具有c++特色的用法）
                    先写入文件，再读入 & ASCII 二进制模式的话要加上binary属性
                    IOS是流式I/O的基类
                    ios::in ios::out定义打开文件的属性
                    写入文件
                        通用法 fstream
                        专用法 ofstream---in file stream 输入文件流
                                初始化的时候默认调用open函数
                                在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。
                    读取文件
                        通用法 fstream
                        专用 ifstream
                            在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。
                            读取一行数据 &，使用ifstream中的getline函数，返回的数据在参数中（参数就是把一个buff）
                    通用法打开文件要加上属性，看起来整齐
                    推荐使用专用法
                    而后就可以用cin cout来操作了
                    文件对象别忘了关闭
                多线程
                    使用pthread开源库 &
                        1.库文件直接放在项目中，引入include等目录
                        2.放置dll文件在cpp文件夹中
                        3.引用lib文件#pragma comment(lib, "pthreadVC2.lib")
                c++ STL库
                    模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈
                    容器（Containers），算法（Algorithms），迭代器（iterators）
                    定义：向量容器<类型> 名称；
                    调用：名称.算法；
                    迭代器相当于指针，进行遍历的工具；
                    动态创建数组，并输出所有元素，显示大小 &
                    push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。
                    begin( ) 函数返回一个指向向量开头的迭代器。
                    size( ) 函数显示向量的大小。
                    C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改
                    标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理
                GUI操作
                    QT
                        概述
                            不用跨平台：因为商业需要只能硬着头皮维护下去，浪费了公司大量的人力财力
                            国内公司只是市场驱动的，它们不是真正技术驱动的公司，
                                很多软件都是用开源改后包装成自己的，依靠垄断存活的
                            QT你不能说他不流行吧, WPS, Wirshark, KDE, dropbox, skype, virtualbox都和qt有关吧, 你想写个跨平台的C++程序, QT是个不错的选择,
                            如果是创业型小公司想开发适配自己公司产品的配套软件并想支持多平台那么Qt是不二的选择。
                                想在4个平台开发软件假设工作量是4，那么用qt可以达到2.5左右。总体工作量减少
                            在桌面Linux和嵌入式领域是主流地位
                            环境搭建https://www.cnblogs.com/happykoukou/p/7457013.html &
                        显示
                        组件
                        附加组件
                        应用
                            本地 &
                                界面类：计算器，登陆界面，图书馆系统
                                文档媒体：图片处理，文件名处理工具
                                游戏：俄罗斯方块，扫雷
                            网络 &
                                http下载器
                                ftp查看器
                                网络发包ping
                延时
                    引入windows头文件，而后可以利用其中的Sleep函数进行延时，单位是毫秒 &
                网络
                    虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi
                    Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序
                    请使用 chmod 755 cplusplus.cgi UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件
                    GET 和 POST 方法 &
                    获取 Cookies
                    文件上传实例
                数据库
            =======================超越API（实现自己的代码库）===================
                注意项目封装
                数值计算的库操作数组
                    eigen库
                        就是一个头文件与一些实现！！
                        重写了一些操作符号，规范
                        矩阵操作，特别是二维矩阵
                        矩阵的乘除加减求逆求行列式
                        Eigen速度最快，与自己定义数组的操作效率相当
                        矩阵存储等有优化
                        All classes and functions defined in this header file 
                            (and other Eigen header files) are in the Eigen namespace！
                        helloworld程序，添加一个矩阵 &
                        随机生成矩阵+矩阵乘法运算 &
                OpenGL库
                OpenCV库
            =======================根据工作要求=======================
                GDB和LLDB
                    他们两个都是调试用的Debugger，只是LLDB是比较高级的版本，或者在调试开发iOS应用时比较好用，不然人家苹果为什么换成了LLDB了呢！
                GCC/Clang（LLVM库）
                    它是一套以 GPL 及 LGPL 许可证所发行的自由软件，也是 GNU计划的关键部分
                    GCC 原名为 GNU C 语言编译器，因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++
                    LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成
                    Clang发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。
                    但Apple对编译工具会提出更高的要求。
                    GCC 基于 C，不需要 C++ 编译器即可编译
                    苹果有关
    ---datastru. 
        ---basic, simple, from stl 
            // heuristics 
                linear
                    双端队列
                    单链表 循环链表...
                    并查集
                    最大团
                    最大独立集 
                    stack,queue
                        use stack/xx container classs, we have to include standerd header files 
                        do not forget std:: namespace !
                        do not forget template arguments 
                    multiset：多重集合，其实就是 set 集合的扩展版。
                        唯一的不同是 set 集合中一个值只能出现一次，
                        而多重集合中一个值可以出现多次。
                        +尝试
                    hash table 
                        hash算法的意义在于提供了一种快速存取数据的方法,它用一种算法建立键值与真实值之间的对应关系
                        key值,一般都是用某种算法(所谓的Hash算法)算出来的.例如:字符串的Hash算法, 
                        这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，    
                            而不可能从散列值来唯一的确定输入值
                        BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。 
                        LINK
                            https://blog.csdn.net/caoshangpa/article/details/78782378
                        哈希表(hash table)是从一个集合A到另一个集合B的映射(mapping)。
                        a被称为键值(key)，b被称为a的hash值(hash value)
                        A: 三位整数    hash(x) = x % 10    B: 一位整数
                        在git中，文件内容为键值，并用SHA算法作为hash function，将文件内容对应为固定长度的字符串(hash值)。
                        如果文件内容发生变化，那么所对应的字符串就会发生变化。git通过比较较短的hash值，就可以知道文件内容是否发生变动
                        为了安全起见，计算机不会直接保存该字符串，而是保存该字符串的hash值(使用MD5、SHA或者其他算法作为hash函数)
                        黑客闯入了数据库中的密码记录，他能看到的也只是密码的hash值。
                        很难从hash值去推测键值。因此，黑客无法获知用户的密码。
                        hash碰撞(hash collision)或者hash 冲突。比如网络协议中的checksum就可能出现这种状况
                        已经有实验表明，MD5算法有可能发生碰撞，也就是不同的明文密码生成相同的hash值，这将给系统带来很大的安全漏洞。
                            (参考hash collision）
                        复杂度直接降到O(1)。Hash表就能够达到这样的效果
                        存储位置只是表中的存储位置，并不是实际的物理地址)称作为Hash地址
                        则当想要找到“李四”的信息时，直接根据“李四”和Hash函数计算出Hash地址即可。
                        DETAIL 
                            假如对上述的联系人信息进行存储时，采用的Hash函数为：姓名的每个字的拼音开头大写字母的ASCII码之和。
                            首先，它浪费了大量的存储空间，空间利用率只有4/174，不到5%
                            另外，根据Hash函数计算结果之后，address(张三)和address(张帅)具有相同的地址，这种现象称作冲突
                            尽量考虑关键字的分布特点来设计函数使得Hash地址随机均匀地分布在整个地址空间当中。
                        *通常有以下几种构造Hash函数的方法，在数学上尽量保证平均  
                            根据特征
                                线性函数:取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;
                                平方取中法:对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，
                                    423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。
                                折叠：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道
                                    图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。
                                分析数字：第一位，第二位，第三位重复的可能性大，取这三位造成冲突的机会增加，所以尽量不取前三位，取后三位比较好
                            普适方法
                                除留取余法：如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。
                                    p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。
                                    典型的除留取余法Hash函数是time33算法。PHP的数组就是把这个作为哈希函数。
                                随机数：H(key)=random(key) ,其中random为随机函数。通常用于关键字长度不等时采用此法。
                        hash表大小要仔细确定
                            还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。
                        如果遇到冲突，哈希表一般是怎么解决的呢？具体方法有很多，百度也会有一堆，最常用的就是开放定址法和链地址法。
                            如果遇到冲突的时候怎么办呢？就找hash表剩下空余的空间，找到空余的空间然后插入。就像你去商店买东西，  
                                发现东西卖光了，怎么办呢？找下一家有东西卖的商家买呗。
                            有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(空间/插入数据)>=1。
                                链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。
                                    我感觉业界上用的最多的就是链地址法。
                                当然也有最坏的情况就是hash值全都映射到同一个地址上，这样哈希表就会退化成链表
                                只要不要把hash计算的公式外漏出去并且有人故意攻击（用兴趣的人可以搜一下基于哈希冲突的拒绝服务攻击）
                                    ，一般也不会出现这种情况。
                        要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的
                            https://blog.csdn.net/u012965373/article/details/38929637
                        example 
                            what i thought out :
                                电话号码本查询
                                    zhangsan 13980593357,20
                                    lisi 15828662334,18
                                    wangwu 13409821234,16
                                    zhangshuai 13890583472,30...
                                    ..
                                store name search (kaggle )
                                    https://www.kaggle.com/starbucks/store-locations/downloads/store-locations.zip/1
                            poj
                                poj3349:
                                    //判断是否有相同的雪花，顺序无关。数字是每一个花瓣的长度
                                        io
                                            2
                                            1 2 3 4 5 6
                                            4 3 2 1 6 5
                                            Twin snowflakes found. or No two snowflakes are alike.
                                        solution
                                            https://blog.csdn.net/lvshubao1314/article/details/42320263
                                            https://blog.csdn.net/hopeztm/article/details/7832750
                                poj3690:
                                    //字符矩阵匹配,找到相应的子矩阵
                                        io
                                            3 3 2 2 2
                                            *00
                                            0**
                                            *00

                                            **
                                            00

                                            *0
                                            **
                                            3 3 2 2 2
                                *00
                                0**
                                *00

                                **
                                00

                                *0
                                0*
                                0 0 0 0 0

                                Case 1: 1
                                Case 2: 2
                            solution 
                                https://blog.csdn.net/u011026968/article/details/38495821
                    广义链表
                        对于线性表而言，n个元素都是基本的单元素，而在广义表中，这些元素不仅可以是单元素，
                            也可以是另一个广义表。通俗的讲，在广义表中的元素，也可以是一个线性表。
                    ...
                tree 
                    基本树的各种遍历
                    优先队列
                    二叉查找树
                    平衡查找树
                    散列表
                    单词查找树
                    堆 红黑 AVL 斐波那契堆 van Emde 树 kd-树（搜索树） BSP树 线段树  博弈树  
                    A*  双向广度优先搜索  ida* algorithm  树状数组  左偏树  多串匹配树  
                    字典树 
                    无根树  
                    trie树(静态建树、动态建树)  
                    B-树、B+树、B*树
                    位置树
                    四叉树：非均匀网格生成
                    八叉树
                    哈夫曼树
                graph 
                        构建
                            图型结构的四种存储结构
                            https://zhuanlan.zhihu.com/p/30343791
                            https://pic3.zhimg.com/80/v2-c444b84c2bcee24205771ec817f4926a_hd.jpg
                            无向图和有向图的存储结构是有区别的
                            数据结构其实只有两种，线性表的顺序结构，和线性表的链式结构
                            +
                                邻接表存储是表示实际上意义的东西，邻接矩阵只是一种简化思路
                                线性链表--只有一个（或扩展成多个）链接域
                                树--有两（左右孩子）（或扩展成多个）个链接域
                                图--有无穷个边，链接域
                                    这时候需要特殊处理：把边链式存储！：：邻接表存储法
                            1.数组，邻接矩阵
                                利用两个数组分别存储顶点（vector）和边（edge）。 
                                顶点用一维数组
                                边用二维数组存储：一个矩阵，无向图的二维数组是关于对角线对称的
                            2.邻接表存储
                                弧头和弧尾都是指顶点，在G1中，对于Ea来说V1是弧头，V2是弧尾
                                其实就利用一个一维数组存储链表
                                数组数据类型：
                                    data域：存储顶点（Vi）的数据信息。 
                                    firstarc域：顾名思义就是该域指向与顶点（Vi）相连的第一条弧（arc）,
                                        这里指的第一条并没有特定的顺序，只是为了和之后的弧进行区分而出现的概念。
                                表节点中有三个域
                                    adjvex，next, info
                                无向图的度就是链表中表节点的个数
                                有向图的度
                                    以（Vi）顶点为头结点的链表后面接着的表节点中是以顶点（Vi）为弧头的弧
                                    要有向图的度还要求出有向图的入度，邻接表中的adjvex域值为i的表节点的
                                        个数是顶点（Vi）的入度。
                                    为了方便求有向图的入度我们引入了逆邻接表
                                +逆邻接表
                            2->十字链表法
                                所谓的十字链表法就是结合了邻接表和逆邻接表，以方便求出图形结构的出度和入度
                                邻接表的改进
                            1->邻接多重表
                                邻接多重表是针对于无向图改进的存储结构
                                这对我们对边进行操作的时候十分不便，假设我要删除一条边，
                                    那么我要在两条链表中去删除这条边两次，这增加了我们程序的复杂度
                                让一条边仅仅用一个节点表示
                                一条边由一个节点六个域表示
                                    ivex和jvex域：这两个域中存储的是顶点的位置,因为一条边连接两个顶点
                                    ilink和jlink域：这两个域中存放的是边的位置，ilink中存储顶点Vi的下一条边的位置。 
                                    info域：可以用来存储边的权值。 
                                    头结点
                        Voronoi图
                        ...  
        ---deeper
            //很多数据结构都不必非要从头实现（如果非要创造新的），在c++ stl中可以复用！
            book--算法竞赛入门经典
                file:///C:/Users/yzy/Desktop/base_c++_oj%20hierarchy/r0-res/chs/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8+%E5%AE%8C%E6%95%B4%E7%89%88.pdf
                ch01
                ch02 
                    ...
                ch03 
                ch04 
                ch05 
                ch06 
                ch07 
                ch08 
                ch09 
                ch10 
                ch11 
            book--算法java
                ch01
                ch02 
                    ...
                ch03 
                ch04 
                ch05 
                ch06
            book--算法导论 en
    ---algorithm
        learnfromseed--exp 
            //在熟悉结构的基础上解决问题
            ---overview
                基本任务
                    排序查找搜索
                算法思想
                    动态规划，分治，xxx
                小领域
                    图论，数论，计算几何，博弈，组合数学
            ---math related 
                整数问题
                    组合数学
                        普通涂色问题 组合数学-Polya定理
                        约瑟夫问题
                        卡特兰数是组合数学中一个常出现在各种计数问题中的数列
                    数论问题：
                        辗转相除（两行内）
                        任意进制间的转换
                        大整数的分解
                        求素数
                            https://www.zhihu.com/question/307930531/answer/566185328
                        最大公约数(Gcd)两种算法(Euclid && Stein) 
                    数字游戏
                    博弈类
                精度
                    提高精度
                        高精度四则运算
                        高精度pi计算
                            使用
                高阶问题
                    矩阵快速乘法
                    快速傅里叶变换
                    fibonacci数列 &
                        用数组，可以在linear 时间中完成
                        很多数列问题都可以
                    解线性方程组
                        +在图形学中应用广泛，CV中，ML中
                        例如mesh parameterization
                        最小化能量方程
                        -
                    解线性规划问题
                        单纯形算法
            ---NP hard problems 
                TSP Travelling salesman problem
                Minesweeper 
                Knapsack problem
                Sudoku
                Set TSP problem
                Hitori一个数字矩阵
                马踏棋盘
                    其实是哈密顿回路问题，但是有棋盘大小制约，本质是NP hard
                Graph coloring
                最小st割问题
                子集合加总问题
                    给定集合{−7, −3, −2, 5, 8}，答案是YES，因为子集{−3, −2, 5}的数字和是0
                    可以想成是背包问题的一个特例
                圍棋是一種 PSPACE-hard 的問題
                +各种棋类
                    概括：
                        启发式搜索和优化减枝的过程
                        国际象棋（他是台湾人，说的是西洋棋）的状态复杂度是 2^64 次方，而围棋则达到 2^128 次方
                        就在今天2016-1-28，《Nature》杂志以封面论文的形式，介绍了 
                            Google DeepMind 开发的人工智能程序 AlphaGo，它击败了欧洲围棋冠军樊麾
                    围棋--唯一一种电脑下不赢人的大众棋类
                        围棋虽说是“千古无同局”，
                        但在局部及开局还是有很多相似或者相同的模式会反复出现，
                        DCNN能够抓住这些模式并且在实战中灵活运用。
                    象棋跳棋
            ---mixed problems 
                基本排序算法*4 
                    归并排序
                二分查找
                背包问题
                记忆化搜索
                各种字符串处理算法！！
                    KMP算法
                        KMP算法俗称“看(K)毛(M)片(P)算法”
                        KMP算法是比较难以理解的算法，但是不繁琐，而是很精妙，值得理解
                    最长上升子序列(Longest Increasing Subsequence)问题
                    最长公共子序列LCS问题					
                    最大子序列 &
                        这个问题之所以有吸引力，主要是因为存在求解它的很多算法，而这些算法的性能差异又很大
                        非常典型的算法优化问题，有多种复杂度实现版本
                        max sum value in subsequence :
                        1.using 2 times for loop :
                            a b c d e f ...
                                ...
                            the ,maximum computational complex is : O(N^2)
                            this is what who havent leared algorithm has wroten
                            pcode：
                                loop outlier array from start to end 
                                    loop from i to end 
                                        check if larger than max 
                        2.using DP algorithm 
                            can run to Nlog(N)
                            this can be applied to other applications 
                            pcode:
                                分三种情况进行递归，选择最小的
                        3.using some mathematical tricks :
                            can be O(N)
                            maybe cannot be applied to others 
                            pcode:
                                loop the array 
                                    if current sum is lower than 0
                                        reset max to next value 
                                    else
                                        add next value
                    levenstein距离
                        最后用了dp的思想解决
                    Boyer-Moore字符串查找算法
                    Rabin-Karp指纹字符串查找算法 
                各种经典策略！！（高级设计分析技术）
                    DP策略
                        四边形不等式理论
                        状态DP
                    分治策略
                    贪心策略
                    回溯法
                        八皇后问题是应用回溯法求解的典型案例。
                        https://web.archive.org/web/20071218075305/http://www.datastructures.info/the-backtracking-algorithmmethod/
                    二分 
                    递归
                        子问题的解解决父问题
                        思维过程：**
                                1.找子问题：多走两步，最好可以证明是子问题（明确画出来）
                                2.设计参数：变量化参数化(找出原来的为啥不行...)
                                    参数要有一定的表达能力
                                    参数要同时表达问题和子问题--观察问题和子问题啥不同
                                        规模不同
                                        借助的柱子不同
                                        ...不同
                                    写出形式化表达：：
                                        父问题：hanoi(n, f, b, t)
                                        子问题：
                                            hanoi(n-1, f, t, b);
                                            hanoi(1, f, b, t);
                                            hanoi(n-1, b, f, t);
                                3.设计停止条件
                        +这里，都写一下：
                            https://segmentfault.com/a/1190000011734845

                        
                        Factorial阶乘
                        汉诺塔问题
                            描述：
                                A->C借助B
                                A上尺寸由下到上依次变小
                                每次只能移动一个圆盘；
                                大盘不能叠在小盘上面。
                            初始结构只是在A上的情况和任意初始结构（arbitrary initial configuration）
                                的解法不同
                            子问题的解解决父问题
                            ---
                            pcode:
                                hanoi(a,b,c){//abc 表示个数（不充分）
                                    if(a==1){
                                        
                                    }else{
                                        print a->b;
                                        hanoi(a-1,b,c);
                                        print b->c;
                                    }
                                }
                                ##以上废弃 ：子问题不明确，变量设计不合理 

                                t是二维数组
                                H(imax,t[0],t[1],t[2])	
                                    H(imax - 1, t[0],t[2],t[1])
                                    print t[],t[]
                                    H(imax - 1, t[1],t[0],t[2])
                                ##自己设计，理论上可以

                                H(n,'a','b','c')
                                ##经过理论分析，最简单设计：：父子之间，n变化，借助的柱子也变化（不仅仅是规模变化）
                        -
                运筹学问题 ！！
                    TSP问题
                    SAT问题
                        SAT的问题被证明是NP难解的问题。
                            目前解决该问题的方法主要有完备的方法和不完备的方法两大类。
                            完备的方法优点是保证能正确地判断SAT问题的可满足性，
                            但其计算效率很低，平均的计算时间为多项式阶
                        传统的方法有：枚举法、局部搜索法和贪婪算法等，但由于搜索空间大，
                            问题一般难以求解。对于像SAT一类的NP难问题，
                            采用一些现代启发式方法如演化算法往往较为有效。
                    NP问题与近似算法
                区间最值算法ST
                    ST 算法是 RMQ（Range Minimum/Maximum Query）
                    中一个很经典的算法，它天生用来求得一个区间的最值
                多线程算法
            ---linear 
                单链表，循环链表...
                并查集
                最大团
                最大独立集
                双端队列
            ---tree 
                基本树的各种遍历
                优先队列
                儿叉查找树
                平衡查找树
                散列表
                单词查找树
                霍夫曼压缩
                堆
                红黑
                AVL
                斐波那契堆
                van Emde 树
                kd-树（搜索树）
                BSP树
                线段树
                博弈树
                A*
                双向广度优先搜索
                ida* algorithm
                树状数组
                左偏树
                多串匹配树
                字典树
                无根树
                Kruskal 最小生成树
                trie树(静态建树、动态建树) 
                BST 二叉搜索树
                B-树、B+树、B*树
                位置树
            ---graph
                basic
                    创建binary tree 
                        Time Complexity: O(n), where n is the total number of nodes in the tree.
                        其实插入和检索可以类似，只是在检索数据的时候赋值而已
                        给出层次遍历的情况：：
                            pcode:
                                void Cons(Node curNode){
                                    curNode.val=Q.pop().val
                                    Cons(curNode.left);
                                    Cons(curNode.right);
                                }
                                --false! 当然也可以给前序来创建树，那样的话用递归就可以
                                Node* insertLevelOrder(arr[], Node* root, int i, int n) 
                                { 
                                    // Base case for recursion 
                                    if (i < n) 
                                    { 
                                        Node* temp = newNode(arr[i]); 
                                        root = temp; 
                                
                                        // insert left child 
                                        root->left = insertLevelOrder(arr, 
                                                root->left, 2 * i + 1, n); 
                                
                                        // insert right child 
                                        root->right = insertLevelOrder(arr, 
                                                root->right, 2 * i + 2, n); 
                                    } 
                                    return root; 
                                } 
                                --too complex!
                                Node * insertLevelOrder(){
                                    root=newNode(a[0]);
                                    Queue q;
                                    q.push(root);
                                    i=0;
                                    while(q.size()!=0){
                                        curNode=q.pop();
                                        if(i<n){
                                            curNode->data()=a[i];
                                        }
                                        if(2*i + 1 < n){
                                            //has left child 
                                            l=newNode();
                                            curNode->left=l;
                                            q.push(l);
                                        }
                                        if(2*i + 2 < n){
                                            r=newNode();
                                            curNode->right=r;
                                            q.push(r);
                                        }
                                        i++;
                                    }
                                }
                                ---Good!
                        给出先序遍历的情况：：
                            Node* PreOrderInsert(a,i){
                                if(i<n){
                                    curNode=newNode();
                                    curNode->data=a[i];
                                    curNode->left=PreOrderInsert(a,i+1);
                                    curNode->right=PreOrderInsert(a,i+2);
                                }else{
                                    return NULL;
                                }
                            }
                            --- i should be global ; should use NULL to 
                            int i=0;
                            Node *PreOrderInsert(int a[], int n)
                            {
                                if (i < n && a[i]!=NULL)
                                {
                                    Node *curNode = (Node *)malloc(sizeof(Node));
                                    curNode->data = a[i];
                                    i++;
                                    curNode->left = PreOrderInsert(a, n);
                                    curNode->right = PreOrderInsert(a, n);
                                    return curNode;
                                }
                                else
                                {
                                    i++;
                                    return NULL;
                                }
                            }
                            ---
                    广度优先搜索
                        实际上可以用数组和结构模拟（数组元素是结构）
                        时间复杂度为O(V+E).即是图邻接表大小的线性函数。
                        pcode :
                            init Queue; boolean visited ;
                            while(q=Q.pop()){
                                if(Obj==q){// can have more options 
                                    return q;
                                }else{
                                    Q.push(q->left())
                                    Q.push(q->right())// can have more childs 
                                    q.visited = true ;
                                }
                            }
                        code tips:
                            Queue:
                                queue<Point>q;-->#include <queue>  
                                q.front();
                                q.pop();
                                q.push();
                        eg.
                            0.Construct a complete binary tree from given array
                            1.given [3,9,20,null,null,15,7] return value 
                            2.find Minimum in log time 
                                given [3,9,20,15,7] find Minimum
                                conpare with linear method (one while loop)
                            .
                        ref
                            https://www.geeksforgeeks.org/construct-complete-binary-tree-given-array/
                            https://stackoverflow.com/questions/33852623/create-binary-tree-in-level-order-from-array
                    寻找路径
                    寻找连通分量
                    最小生成树
                    拓扑排序
                    最短路径
                        单源最短路径dijkstra
                        多源最短路径
                运筹学
                    最大流算法
                    最小费用流
                    最大匹配算法
                advanced
                    Voronoi图
                    四叉树：非均匀网格生成
                    八叉树
                    光线跟踪求交点问题
                    铸造（casting） 问题（其实是线性规划问题）
                    欧拉路
                    最小度限制生成树（变种）
                    差分约束系统的建立和求解.
                    图的割边和割点
                    Beam Search（集束搜索）
                        一种启发式图搜索算法，通常用在图的解空间比较大的情况下，
                            为了减少搜索所占用的空间和时间
            ---computational geometry
                空间剖分（space partitioning）
                    三角剖分算法
                    Delaunay三角剖分
                图的对偶变换
                凸包与半空间求交
                叉乘、判线段相交、然后写个凸包. 
                线段交点、多角形面积公式.
        online--
            cpu其实很慢，这就是必须要学算法的原因。
                面对指数级或是排列组合级别的各种计算，
                每秒几亿次的运算速度根本不够看
            算法其实就是楼房地基一个重要的组成部分。勿在浮沙筑高台，
            学好算法，是让自己能够在程序员的道路上走得更远的一个重要保证。
        book-- 
        book--          
    ---libs.
    ---比赛面试资源
        定期比赛网站
            Bestcoder：我们常打的比赛，题目质量待考究，不过用来每周练练手还是不错的。
            Codeforces：题目质量较高，你的得分rating也是未来找工作的一个可信度很高的衡量标准。
            Topcoder：没打过，听说很难。
    ---for review---prog. task list -- from beginner to expert  
        ---lan. spec.
            // not so much for oj coding 
            mixed
                t- demostrate map/hash/list/vector/heap... usage!!
                t- demostrate xxx usage!!
            File IO
                read/write file 
                ...
            Network
                ... 
        ---Beginner Exercises 
            // DS free tasks from oj! for all lan. (vs lan-feature based)
            //  heuristics: 
                部分高中数学题目，尤其是数论有关
                poj水题目, or other ojs 
                c语言遗产
                data sci., basic vis. , img based
                search online "basic programming tasks" 
                    https://www.w3resource.com/cpp-exercises/basic/index.php
                    ...
                basic math problems
                small logic problems
                paint in command linea 
                (what you have done as bechlor)
                https://blog.csdn.net/qq429205464/article/details/6732899
                https://blog.csdn.net/qq_17246605/article/details/52136415
            t- math calcu:
                add 10 numbers together - use calcu.or to varify
                求1+2+3+......+n
                sum of 2d array/3d array - calculator
                gaussian blur, stencil function , compare from net
                出现次数最多的数
                zigzag-https://blog.csdn.net/wangfengfan1/article/details/47071095
                    -later 
            t- find.spec.numbers
                prime
                shuixianhua shu
            t- 基本排序算法*4 
                -shouldbesummerized
                -net
            t- rabbit:20 iteraters, 4 each line 
                -snippets
            t- fibonaqi:store 40 numbers , F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
                loop / swap
                -snippets
            t- 百钱买百鸡:公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱， 用100文钱买一百只鸡,其中公鸡，
                母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱？
                brust loop
                -snippets
            t- 魔方矩阵calcu-将自然数1到N^2填充N行N列的方阵，使方阵中每行、每列及两条主对角
                线上的N个数的和都等于N*(N^2+1)/2，这样的方阵称为N阶魔方矩阵（幻方）
                +
                    strategy 
                        魔方矩阵的构造分为三种情况：N为奇数、N为4的倍数、N为其他数（偶数，4N+2的形式）
                        https://www.cnblogs.com/xkfz007/archive/2012/11/13/2767407.html
                    brust loop ok 
            t- Magic square judge
                +https://blog.csdn.net/qq_36203090/article/details/55223867
                loop/2d array
            t- sum/multiple/xxx(basic math) two numbers 
                input: 12 24
                output: 36
                check: with calcu. (online is ok)
            t- loop over to print numbers/shapes
                10times 2d loop
                yanhui triangle 
                triangle with * 
                ...
            t- dsf- jitu tonglong 
            t- dsf- 水仙花数， xxx数
            ---https://www.w3resource.com/cpp-exercises/basic/index.php
            t- Print the American flag
                expected io: clear 
            t- find the area of Scalene Triangle
                expected io:
                    Input the length of a side of the triangle : 5
                    Input the length of another side of the triangle : 6
                    Input the angle between these sides of the triangle : 6
                    The area of the Scalene Triangle is : 1.56793
                n28, https://www.w3resource.com/cpp-exercises/basic/index.php
            t- convert temperature in Celsius to temperature in Fahrenheit
                ref. https://www.w3resource.com/cpp-exercises/basic/index.php   
                -
            t- compute the total and average of four numbers
            t- show the diff. size of float, double vars. 
                size of bool? 
                expected: (test cases:)
                    The sizeof(char) is : 1 bytes
                    The sizeof(short) is : 2 bytes
                    The sizeof(int) is : 4 bytes
                    The sizeof(long) is : 8 bytes
                    The sizeof(long long) is : 8 bytes
                    The sizeof(float) is : 4 bytes
                    The sizeof(double) is : 8 bytes
                    The sizeof(long double) is : 16 bytes
                    The sizeof(bool) is : 1 bytes
            t- check the upper and lower limits of integer.
                (use INT_MAX, INT_MIN...) 
                    The maximum limit of int data type :                  2147483647      
                    The minimum limit of int data type :                  -2147483648     
                    The maximum limit of unsigned int data type :         4294967295      
                    The maximum limit of long long data type :            9223372036854775807                                                                    
                    The minimum limit of long long data type :             -9223372036854775808                                                                  
                    The maximum limit of unsigned long long data type :   18446744073709551615                                                                   
                    The Bits contain in char data type :                  8               
                    The maximum limit of char data type :                 127             
                    The minimum limit of char data type :                 -128            
                    The maximum limit of signed char data type :          127             
                    The minimum limit of signed char data type :          -128            
                    The maximum limit of unsigned char data type :        255             
                    The minimum limit of short data type :                -32768          
                    The maximum limit of short data type :                32767           
                    The maximum limit of unsigned short data type :       65535
            t- find the area of any triangle using Heron's Formula.
                Heron's formula states that the area of a triangle whose sides have lengths
                semiperimeter of a polygon is half its perimeter
                exp:
                    Input the length of 1st side of the triangle : 5
                    Input the length of 2nd side of the triangle : 6
                    Input the length of 3rd side of the triangle : 7
                    The area of the triangle is : 14.6969
            t- calculate area of an equilateral triangle
                exp:
                    Input the value of the side of the equilateral triangle: 5
                    The area of equilateral triangle is: 10.8253
            t- calcu. the area of a hexagon
                io:
                    Input the side of the hexagon: 6
                    The area of the hexagon is: 93.5307
            t- compute the shortest distance between two points on the surface of a sphere
                given https://en.wikipedia.org/wiki/Great-circle_distance as ref. 
                    + radians, the calcu. of arc length d 
                        what is latitude? be transfered to angle? radiance? 
                        radians is bet. (0-3.1415... when we have angle bet. 0 to 360? unit circle? )
                io:
                    Input the latitude of coordinate 1: 25
                    Input the longitude of coordinate 1: 35
                    Input the latitude of coordinate 2: 35.5
                    Input the longitude of coordinate 2: 25.5
                    The distance between those points is: 1480.08
            t- gen. primes within 1000000 quickly(not using table, hard for coding)
                io: clear 
            t- mem allocation precisely 
            t- string calculator 
                io clear.
                ltc. 
            t- swap all digits of a decimal number 
            t- from decimal to binary calcu. or, other forms  
                ltc.
            t- swap only two digits, the first and the last 
                -> math calcu. 
            t- string replacement with in a string text 
                io clear. 
            t- find max element in an array with custom comparation func. std::max_ele...
                http://www.cplusplus.com/reference/algorithm/max_element/   
            ---https://edabit.com/challenges/cpp
            t- validate a string by checking if there is any space 
                hasSpaces("hello") ➞ false
                hasSpaces("hello, world") ➞ true
                hasSpaces(" ") ➞ true
                hasSpaces("") ➞ false
                hasSpaces(",./!@#") ➞ false   
            ---https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/ leetcode!    
                restricted, but still, can observe some
            t- paint in command line - loop/ifelse
                triangles
                form of v / other alphabets 
                form of chinese words   
            t- levenshtein distance -later, dp
            t- hanoi: from a to c with help of b 
                recur.                
        ---oj hierarchy （原子问题） 
            DS based tasks(not only stl)
                // heuristics:
                    NP problems(theory review first)
                    oj 
                    books 
                simple-ones, use set, map, 
                list-based 
                    t- ...
                tree-based 
                    basic bin. tree
                    advanced trees:
                    ...
                graph-based 
                created_stru-based 
                t- demostrate xxx DS!!
            Algo. based 
                // algo problems?? NP hard? 
                t- demostrate diff. sorting algos! 
                t- demostrate xxx algos!
            -> vis. and interaction with algos. 
                proj.
            competition 
                huawei 
                tencent 
                ...
            ---
            reasoning, triple analysis(graph)
                ...
        *---mixed problem (+刷题)
            //res 
                https://blog.csdn.net/h273979586/article/details/69786603 
                http://www.pythontip.com/acm/problemCategory
                查找（二分、哈希）：poj3349、poj1002、hdu2141、hdu1025
                串（AC自动机、KMP）：hdu3695、hdu2203、sdut2411、poj2406、hdu1358、hdu3336
                并查集：poj2236、poj2524、poj1182、poj1611、hdu1232
                字典树：poj2503、poj2001、hdu1247、hdu1075、hdu1251
                树状数组：hdu1556、poj1195、poj3321、hdu1541/poj2352
                线段树：poj2155、poj1195、poj3468、poj3264、hdu1556、hdu1698、hdu1754、hdu1166
                划分树：poj2104、sdut2610
            ---unknown mixed source 
                数组右移k位
                AABB空间搜索 ++
                    其实是通过剪枝加快搜索
                    建立一个树结构，只要树高减小，可能能到logN
            ---poj
                poj 1050 最大子矩阵 ++
                    其实是一个矩阵，但是可以简化成数组问题（压扁）
                    原子问题：最大子序列，dp
                poj 3750 小孩报数问题 ++
                    用循环链表更合适 
                    原子问题：循环链表
    ---build a data processing framework
        data 
            https://www.kaggle.com/AnalyzeBoston/crimes-in-boston
                date and location info 
            https://www.kaggle.com/gsi-japan/global-map-japan-data/downloads/global-map-japan-data.zip/1
                img info
            https://www.kaggle.com/doit-intl/autotel-shared-car-locations
                location information 
            https://www.kaggle.com/open-flights/flight-route-database
                route information 
            https://www.kaggle.com/fivethirtyeight/uber-pickups-in-new-york-city
                time and adress data info 
            https://www.kaggle.com/berkeleyearth/climate-change-earth-surface-temperature-data
                temperature and place 
            https://www.kaggle.com/google/google-landmarks-dataset#train.csv
            https://www.kaggle.com/c/landmark-retrieval-challenge
                not c++ / deep lerning project 
            https://www.kaggle.com/START-UMD/gtd
                location , summary xxx
            
        persers 
            csv reader  
                https://github.com/ben-strasser/fast-cpp-csv-parser
                    head only 
                https://github.com/vincentlaucsb/csv-parser
                https://github.com/d99kris/rapidcsv
            json reader 
                https://github.com/dropbox/json11
                https://github.com/open-source-parsers/jsoncpp
                https://github.com/taocpp/json
                https://github.com/nbsdx/SimpleJSON